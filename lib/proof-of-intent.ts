import { ethers } from 'ethers';

export interface ProofOfIntentData {
  message: string;
  signature: string;
  timestamp: Date;
  agentId: string;
  creatorWallet: string;
}

export interface ProofVerificationResult {
  isValid: boolean;
  error?: string;
  recoveredAddress?: string;
}

/**
 * Generate a proof of intent message for agent creation
 * This message will be signed by the agent creator to prove their intent
 */
export function generateProofOfIntentMessage(
  agentId: string,
  creatorWallet: string,
  agentName: string,
  timestamp: Date = new Date()
): string {
  const message = `I, ${creatorWallet}, hereby declare my intent to create and operate the trading agent "${agentName}" (ID: ${agentId}) on the Maxxit platform.

By signing this message, I acknowledge that:
1. I am the legitimate creator of this agent
2. I will be responsible for all signals generated by this agent
3. I understand the risks and implications of automated trading
4. I consent to the platform's terms of service

Timestamp: ${timestamp.toISOString()}
Agent ID: ${agentId}
Creator Wallet: ${creatorWallet}`;

  return message;
}

/**
 * Verify a proof of intent signature
 */
export async function verifyProofOfIntent(
  message: string,
  signature: string,
  expectedAddress: string
): Promise<ProofVerificationResult> {
  try {
    // Recover the address from the signature
    const recoveredAddress = ethers.utils.verifyMessage(message, signature);
    
    // Check if the recovered address matches the expected address
    const isValid = recoveredAddress.toLowerCase() === expectedAddress.toLowerCase();
    
    return {
      isValid,
      recoveredAddress,
      error: isValid ? undefined : `Address mismatch. Expected: ${expectedAddress}, Got: ${recoveredAddress}`
    };
  } catch (error: any) {
    return {
      isValid: false,
      error: `Signature verification failed: ${error.message}`
    };
  }
}

/**
 * Create a proof of intent by signing a message with MetaMask
 */
export async function createProofOfIntentWithMetaMask(
  agentId: string,
  creatorWallet: string,
  agentName: string
): Promise<ProofOfIntentData> {
  if (!window.ethereum) {
    throw new Error('MetaMask is not installed');
  }

  const timestamp = new Date();
  const message = generateProofOfIntentMessage(agentId, creatorWallet, agentName, timestamp);

  try {
    // First, request account access if not already connected
    const accounts = await window.ethereum.request({
      method: 'eth_requestAccounts',
    });

    if (!accounts || accounts.length === 0) {
      throw new Error('No accounts found. Please connect your wallet.');
    }

    const connectedAddress = accounts[0];
    if (connectedAddress.toLowerCase() !== creatorWallet.toLowerCase()) {
      throw new Error(`Connected wallet (${connectedAddress}) does not match expected wallet (${creatorWallet})`);
    }

    // Request signature from MetaMask
    const signature = await window.ethereum.request({
      method: 'personal_sign',
      params: [message, creatorWallet],
    });

    return {
      message,
      signature,
      timestamp,
      agentId,
      creatorWallet
    };
  } catch (error: any) {
    if (error.code === 4001) {
      throw new Error('User rejected the signature request');
    } else if (error.code === -32002) {
      throw new Error('Signature request is already pending. Please check MetaMask.');
    } else {
      throw new Error(`Failed to create proof of intent: ${error.message}`);
    }
  }
}

/**
 * Validate proof of intent data structure
 */
export function validateProofOfIntentData(data: any): data is ProofOfIntentData {
  return (
    data &&
    typeof data.message === 'string' &&
    typeof data.signature === 'string' &&
    data.timestamp instanceof Date &&
    typeof data.agentId === 'string' &&
    typeof data.creatorWallet === 'string' &&
    ethers.utils.isAddress(data.creatorWallet)
  );
}

/**
 * Generate a unique proof of intent message hash for database storage
 */
export function generateProofHash(message: string, signature: string): string {
  return ethers.utils.keccak256(
    ethers.utils.defaultAbiCoder.encode(
      ['string', 'string'],
      [message, signature]
    )
  );
}
