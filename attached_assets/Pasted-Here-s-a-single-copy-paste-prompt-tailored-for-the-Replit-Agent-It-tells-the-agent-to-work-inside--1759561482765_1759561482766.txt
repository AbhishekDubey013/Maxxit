Here‚Äôs a single, copy-paste prompt tailored for the Replit Agent. It tells the agent to work inside the current repo, audit sequentially by use-case, and patch only what‚Äôs missing‚Äîno scaffolding a new project.

‚∏ª

Prompt for Replit Agent: ‚ÄúSequential Backend Audit & Patch (no re-scaffold)‚Äù

Do NOT scaffold, replace, or restructure the project.
Work in this repo as-is. For each step below, verify the functionality. If missing or failing, add the smallest possible change to make it pass. After each fix, re-run the step before moving on. Keep a running change log. Do not expose secrets client-side.

Global rules
	‚Ä¢	Keep all Neon REST calls server-side only (no tokens in client).
	‚Ä¢	Reuse existing framework/dirs; add files only when necessary.
	‚Ä¢	If an env var is missing, add it to .env.example and read it in server code.
	‚Ä¢	Prefer small modules over big rewrites.

Assumed env vars (don‚Äôt hardcode)
	‚Ä¢	NEON_REST_URL (Neon PostgREST base URL)
	‚Ä¢	NEON_REST_TOKEN (Bearer token)
	‚Ä¢	REDIS_URL (if queues present; otherwise skip gracefully)

‚∏ª

SEQUENTIAL CHECKLIST (verify ‚Üí fix ‚Üí re-check)

1) Health & Readiness
	‚Ä¢	Ensure /api/health ‚Üí 200 {status:"ok"}.
	‚Ä¢	Ensure /api/ready checks Neon REST reachability (e.g., agents?limit=1) and Redis (if used).
	‚Ä¢	If missing, add minimal routes using current server style.

2) Neon REST Proxy (server-only)
	‚Ä¢	Confirm a server route (e.g., /api/db/*) forwards to ${NEON_REST_URL} with headers:
Authorization: Bearer ${NEON_REST_TOKEN}, Content-Type: application/json, and Prefer: return=representation for writes.
	‚Ä¢	Add a 5s timeout + friendly errors.
	‚Ä¢	Grep repo to ensure no client code references NEON_REST_TOKEN.
	‚Ä¢	If weak/missing, implement a single reusable server helper and refactor callers.

3) Agents (CRUD subset)
	‚Ä¢	POST /api/agents creates an agent; validate weights length 8 and each 0‚Äì100; require venue, status.
	‚Ä¢	GET /api/agents supports status, venue, sorting by apr_30d, pagination.
	‚Ä¢	GET /api/agents/:id returns details.
	‚Ä¢	PATCH /api/agents/:id updates status, weights.

4) Agent ‚Üî X Accounts link
	‚Ä¢	Confirm junction table exists: agent_accounts(agent_id, ct_account_id, unique).
	‚Ä¢	Endpoints:
	‚Ä¢	GET /api/agents/:id/accounts
	‚Ä¢	POST /api/agents/:id/accounts { ct_account_id } (upsert)
	‚Ä¢	DELETE /api/agents/:id/accounts/:ct_account_id
	‚Ä¢	If table missing, create via Neon REST SQL endpoint or provide the exact SQL in a migration note and proceed with endpoints.

5) Deployments
	‚Ä¢	POST /api/deployments { agent_id, user_wallet, safe_wallet } ‚Üí defaults status: ACTIVE, sub_active: true.
	‚Ä¢	GET /api/deployments?agent_id=&user_wallet= lists.
	‚Ä¢	PATCH /api/deployments/:id toggles status/sub_active.
	‚Ä¢	Add RelayerService.installModule(safe_wallet) stub and log to audit.

6) Signals (read)
	‚Ä¢	GET /api/signals?agent_id=&token_symbol=&from=&to= ordered by created_at desc.
	‚Ä¢	Add bucket6hUtc(ts) helper and ensure any creation path enforces 6h de-dupe (pre-check) even if DB constraint isn‚Äôt present here.

7) Minimal Signal Creation path
	‚Ä¢	Add a callable service/worker that:
	‚Ä¢	Reads candidate ct_posts (is_signal_candidate=true), latest market_indicators_6h, agent weights, and linked agent_accounts.
	‚Ä¢	Verifies venue availability in venues_status.
	‚Ä¢	Inserts into signals only if no duplicate for (agent_id, token_symbol, 6h bucket).
	‚Ä¢	Provide admin trigger: POST /api/admin/run-signal-once to execute once for testing.

8) Trade Execution (open)
	‚Ä¢	Implement executeTrade(signal_id) that:
	‚Ä¢	Finds ACTIVE deployments for the signal‚Äôs agent.
	‚Ä¢	Computes size from sizeModel (stub ok), enforces min_size/slippage via venues_status.
	‚Ä¢	Calls stub adapters (GMX/Hyperliquid/Spot) and/or RelayerService.
	‚Ä¢	Inserts positions (open) with unique (deployment_id, signal_id).
	‚Ä¢	Admin trigger: POST /api/admin/execute-trade-once?signal_id=....

9) Trade Exit (close + PnL)
	‚Ä¢	Implement closeTrade(position_id) to set closed_at, exit_price, pnl.
	‚Ä¢	Admin helper: POST /api/admin/close-trade-simulated?position_id=...&pnl=....

10) Metrics & Impact
	‚Ä¢	On close, upsert pnl_snapshots (deployment_id, day).
	‚Ä¢	Update denorm APR fields on agents (apr_30d, apr_90d, apr_si; simple calc ok).
	‚Ä¢	Insert impact_factor_history tied to the signal‚Äôs source_tweets.

11) Billing
	‚Ä¢	On close, insert billing_events:
	‚Ä¢	INFRA_FEE = 0.20 always.
	‚Ä¢	PROFIT_SHARE = 10% * pnl only if pnl > 0.
	‚Ä¢	Monthly subscription job (or admin route) inserts SUBSCRIPTION = 20 and updates next_billing_at.

12) Marketplace reads
	‚Ä¢	Ensure fast reads:
	‚Ä¢	GET /api/agents can return id,name,venue,apr_30d,apr_90d,apr_si,sharpe_30d.
	‚Ä¢	GET /api/pnl/daily?agent_id= proxies pnl_snapshots ordered by day asc.

13) Security checks
	‚Ä¢	Verify no client bundle contains NEON_REST_TOKEN.
	‚Ä¢	All Neon requests go through server proxy or server controllers only.

14) Self-check script
	‚Ä¢	Add scripts/selfcheck.(ts|js) that:
	‚Ä¢	Hits /api/ready.
	‚Ä¢	Creates a temp agent (POST), links 1 CT account, creates a deployment, inserts a dummy signal (via admin), executes a trade (admin), closes it (admin), then verifies rows in positions, pnl_snapshots, billing_events.
	‚Ä¢	Cleans up temp data.
	‚Ä¢	Add npm script: "selfcheck": "node scripts/selfcheck.js" (or ts-node).

15) README patch
	‚Ä¢	Append a short section: how to run npm run selfcheck, list of core endpoints, and where the Neon proxy lives.

‚∏ª

Output required from you (Replit Agent):
	‚Ä¢	A concise step-by-step report (1‚Üí15) with: ‚úÖ passed / üîß fixed / ‚è≠Ô∏è skipped.
	‚Ä¢	List of files changed/added per step.
	‚Ä¢	Final instruction to run: npm run selfcheck and sample env needed.

Remember: Do not scaffold a new project. Make minimal, localized changes until every step passes.