Awesome—here’s a single, copy-paste **Replit AI prompt** that will push Ghostwriter/Agent to scaffold your whole **Maxxit** backend (API + workers) in one go. It’s written as a spec + acceptance checklist so the agent knows exactly what to build.

---

## Prompt for Replit (paste this into Replit AI / “Generate Project”)

**Project:** Maxxit — Agentic DeFi Backend (API + Jobs)

**Goal:** Generate a production-ready Node.js/TypeScript backend that implements:

* REST API (NestJS) over PostgreSQL (Neon) via Prisma
* Redis + BullMQ for background jobs
* Minimal venue adapters (GMX/Hyperliquid/Spot) with stubbed calls
* Safe/Relayer stubs for non-custodial execution
* Auth (wallet-based placeholder), billing rules, and metrics logic
* Schema exactly matches the tables I already created in Postgres

---

### Tech & Conventions

* Node 20, TypeScript, **NestJS**
* ORM: **Prisma** (PostgreSQL)
* Queue: **BullMQ** (Redis)
* Lint/format: ESLint + Prettier
* Testing: Vitest (or Jest) minimal
* Config via `.env` + Zod validation
* Monorepo-ish single app: `src/api` (controllers/services) + `src/workers` (queues/processors) + `src/adapters`

---

### Environment Variables (create `.env.example` and config validation)

```
DATABASE_URL=
REDIS_URL=
JWT_SECRET=
X_API_KEY=
RELAYER_URL=
SAFE_MODULE_ADDR=
BILL_INFRA_FEE_USDC=0.20
BILL_PROFIT_SHARE_BPS=1000
SUBSCRIPTION_USD_MONTH=20
```

---

### Data Models (Prisma)

Create Prisma models reflecting this schema (names/types as close as possible). Use `@id @default(uuid())`, `DateTime` timestamps, `Json` for JSON fields, and unique indexes. (We’ll align with the live Neon DB later.)

* CtAccount(id, xUsername unique, displayName?, followersCount?, impactFactor default 0, lastSeenAt?)
* CtPost(id, ctAccountId FK→CtAccount, tweetId unique, tweetText, tweetCreatedAt, isSignalCandidate default false, extractedTokens string[])
* Agent(id, creatorWallet, name, venue enum {SPOT, GMX, HYPERLIQUID}, status enum {DRAFT, ACTIVE, PAUSED} default DRAFT, weights int[8] (validate in code), apr30d?, apr90d?, aprSi?, sharpe30d?)
* AgentDeployment(id, agentId FK→Agent, userWallet, safeWallet, status enum default ACTIVE, subActive boolean default true, subStartedAt default now, trialEndsAt?, nextBillingAt?, unique (userWallet, agentId))
* MarketIndicators6h(id, tokenSymbol, windowStart, indicators Json, unique (tokenSymbol, windowStart))
* Signal(id, agentId FK→Agent, tokenSymbol, venue enum, side string, sizeModel Json, riskModel Json, sourceTweets string[], createdAt)

  * **Note:** add `@@unique([agentId, tokenSymbol, createdAt])` and enforce 6h dedupe in service with a helper `bucket6hUtc(createdAt)`.
* Position(id, deploymentId FK→AgentDeployment, signalId FK→Signal, venue enum, tokenSymbol, side, qty Decimal, entryPrice Decimal, stopLoss?, takeProfit?, trailingParams Json?, openedAt, closedAt?, exitPrice?, pnl?, unique(deploymentId, signalId))
* BillingEvent(id, positionId? FK→Position, deploymentId FK→AgentDeployment, kind enum {SUBSCRIPTION, INFRA_FEE, PROFIT_SHARE}, amount Decimal, asset default "USDC", status enum {CHARGED, FAILED}, occurredAt default now, metadata Json?)
* PnlSnapshot(id, agentId FK→Agent, deploymentId FK→AgentDeployment, day Date, pnl?, returnPct?, unique(deploymentId, day))
* ImpactFactorHistory(id, ctAccountId FK→CtAccount, signalId? FK→Signal, positionId? FK→Position, pnlContribution?, weight?, modelVersion?, occurredAt default now)
* VenueStatus(id, venue enum, tokenSymbol, minSize?, tickSize?, slippageLimitBps?, index(venue, tokenSymbol))
* TokenRegistry(id, chain, tokenSymbol, tokenAddress, preferredRouter?, unique(chain, tokenSymbol))
* AuditLog(id, eventName, subjectType, subjectId?, payload Json?, occurredAt default now, index(eventName, occurredAt))

---

### API (NestJS) — Controllers & Routes

**Auth**

* `POST /auth/siwe` → placeholder to verify signature + issue JWT
* `GET /me` → return wallet, roles, my deployments

**Agents**

* `GET /agents?venue=&status=&sort=apr30d&limit=&page=` → list leaderboard (use denorm metrics)
* `GET /agents/:id` → details + recent performance
* `POST /agents` (creator) → create with `weights[8]` validation (0..100)
* `PATCH /agents/:id` (owner/admin) → update `status`, `weights`

**Deployments**

* `POST /deployments` body: `{agentId, safeWallet}` → also call `RelayerService.installModule(safeWallet)`
* `PATCH /deployments/:id` → pause/resume/cancel
* `GET /deployments?agentId=&me=1`

**Signals** (read-only)

* `GET /signals?agentId=&tokenSymbol=&from=&to=`

**Positions** (read-only)

* `GET /positions?deploymentId=&status=open|closed`

**Billing** (read-only)

* `GET /billing?deploymentId=`

**Admin**

* `POST /admin/refresh-venues` → upsert `VenueStatus` + `TokenRegistry`
* `POST /admin/rebuild-metrics?agentId=` → recompute apr/sharpe from `PnlSnapshot`/`Position`

Add DTOs with class-validator; global exception filter; OpenAPI at `/docs`.

---

### Workers (BullMQ queues & processors)

Set up `src/workers` with queue names and processors:

* `tweetIngest` (CRON 6h/account) → call X API, **create CtPost** (ignore on duplicate `tweetId`)
* `classify` → LLM classify; **update CtPost** (`isSignalCandidate`, `extractedTokens`); if candidate → enqueue `signalCreate`
* `indicators` (CRON 6h/token) → compute features; **upsert MarketIndicators6h**
* `signalCreate` → for each candidate: check `VenueStatus`; read `Agent` configs; **create Signal** unless 6h duplicate (helper `bucket6hUtc`); enqueue `executeTrade`
* `executeTrade` → for each active deployment: compute size from `sizeModel`; guard `minSize/slippage`; call venue adapter + **create Position** (open)
* `riskExit` → monitor until SL/TP/trailing; close; **update Position** (close + pnl); enqueue `metrics` + `billing`
* `metrics` → **upsert PnlSnapshot** (by deployment/day), **update Agent** denorm APR/Sharpe, **insert ImpactFactorHistory**
* `billing` → on close: **create BillingEvent** `INFRA_FEE=0.20`; if `pnl>0` add `PROFIT_SHARE=10%*pnl`; monthly CRON: `SUBSCRIPTION=20` + update `nextBillingAt`

Provide `bull-board` optional route at `/admin/queues` (basic auth).

---

### Adapters & Services (stubs ok)

* `RelayerService` → `installModule(safeWallet)`, `callModule(tx)`
* `GmxAdapter`, `HyperliquidAdapter`, `SpotAdapter`:

  * `pairExists(token: string): Promise<boolean>`
  * `placeOrder(params): Promise<{ entryPrice: number; qty: string; txHash: string }>`
  * `closePosition(params): Promise<{ exitPrice: number; txHash: string }>`
  * `minSize(token): Promise<string>`, `tickSize(token): Promise<string>`, `slippageGuard(bps): Promise<number>`
* `RiskService` → SL/TP/trailing logic
* `SizingService` → balance-% and fixed-notional sizing from `sizeModel`

---

### Directory Layout (target)

```
/src
  /api
    /auth  /agents  /deployments  /signals  /positions  /billing  /venues  /audit  /admin
  /workers
    queues.ts
    tweetIngest.processor.ts
    classify.processor.ts
    indicators.processor.ts
    signalCreate.processor.ts
    executeTrade.processor.ts
    riskExit.processor.ts
    metrics.processor.ts
    billing.processor.ts
  /adapters
    gmx.adapter.ts
    hyperliquid.adapter.ts
    spot.adapter.ts
    relayer.service.ts
  /shared
    bucket.ts        // bucket6hUtc helper
    sizing.ts        // sizeModel helpers
    risk.ts          // trailing SL utils
    dto.ts           // shared DTOs & validators
    prisma.service.ts
    config.ts        // zod env validation
main.ts
app.module.ts
```

---

### Implementation Notes (must do)

* Add `bucket6hUtc(createdAt)` helper to enforce de-dupe in Signal service before create.
* Validate `weights` length = 8 and each 0..100 in Agent service.
* On position close: enqueue metrics + billing immediately.
* Subscription CRON: `$20/month` per active deployment, first month free if `trialEndsAt` in future.
* Return **paginated** results on list endpoints (`limit`, `page`) with defaults.

---

### Scripts & Commands

* `dev`: run API + workers with nodemon/ts-node
* `build` & `start`: compiled with tsup/tsc
* `prisma:migrate`: apply migrations
* `prisma:gen`: generate client
* `seed`: create sample Agents, Deployments, VenueStatus
* `test`: run unit/e2e tests (a couple is fine)

---

### Acceptance Checklist (don’t finish until these pass)

* [ ] Repo builds and `npm run dev` starts API (port 3000) and workers (BullMQ)
* [ ] `/docs` shows Swagger with all routes
* [ ] Prisma schema matches models above; migrations created
* [ ] Endpoints work against a local Postgres (or Neon) when `.env` is set
* [ ] Queues exist; processors are wired; CRON jobs declared
* [ ] Stubs exist for adapters & relayer with TODOs
* [ ] Basic tests for: create agent, create deployment, list agents
* [ ] `seed` script populates 3 Agents, 3 Deployments, VenueStatus rows

**Deliver all code now. If something is ambiguous, choose sensible defaults and document in README.**

---

If you want, I can craft a **second prompt** that feeds your actual Neon connection string and generates a **database seeder** aligned with your live tables.
